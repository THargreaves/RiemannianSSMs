"""
Pretty damn fast now. Few slow-downs due to allocations which can easily be made in-place.

Roughly 25% of time is spent allocating. Some of these are easy to fix, some such as the
ones generated by addition are a bit harder.

Could consider static arrays of static arrays but worry about when K is large. In-place
operations might be the cleanest method.

This is at K = 20 though and as dimension grows this becomes more negligible.
"""

using Distributions
using LinearAlgebra
using Plots
using ProgressMeter
using Random
using StaticArrays

using RiemannianSSMs

SEED = 4
rng = MersenneTwister(SEED)

K = 100
δt = 1.0

μ0 = @SVector [0.0, 0.0, 0.0, 0.0]
Σ0 = Diagonal(@SVector([0.5, 0.5, 0.1, 0.1]))

prior = MvNormal(μ0, Σ0)

α = 0.01
β = 0.1
γ = 0.005
σ_p = 0.1
σ_v = 0.5

dyn = VariableRestoringForceDynamics(α, β, γ, σ_p, σ_v, δt)

a1, b1 = -5.0, 0.0
a2, b2 = 5.0, 0.0
σ1 = 0.5
σ2 = 0.5

obs = TwoLandmarkMeasurementModel(a1, b1, a2, b2, σ1, σ2)

struct SSM{PT,DY,OM}
    prior::PT
    dyn::DY
    sensor::OM
end
ssm = SSM(prior, dyn, obs);

function simulate(rng::AbstractRNG, ssm, K::Int)
    zs = Vector{SVector{4,Float64}}(undef, K)
    ys = Vector{SVector{2,Float64}}(undef, K)

    for k in 1:K
        if k == 1
            z = SVector{4,Float64}(rand(rng, ssm.prior))
        else
            z = f(ssm.dyn, zs[k - 1]) + rand(rng, MvNormal(zeros(4), calc_Q(ssm.dyn)))
        end
        zs[k] = z

        y = h(ssm.sensor, z) + rand(rng, MvNormal(zeros(2), calc_R(ssm.sensor)))
        ys[k] = y
    end

    return zs, ys
end
zs_true, ys = simulate(rng, ssm, K);

zs_true = BlockVector{Float64,4}(zs_true)

lf_params = LeapfrogParams{Float64}(0.01, 1e-6, 1000)

N_samples = 10000
N_burnin = 0
n_steps = 10

function sample!(
    zs_samples,
    rng::AbstractRNG,
    ssm::SSM,
    z_init::BlockVector{Float64,4},
    ys::Vector{SVector{2,Float64}},
    N_samples::Int,
    N_burnin::Int,
    n_steps::Int,
    lf_params::LeapfrogParams{Float64};
    progress=true,
)
    zs_curr = copy(z_init)
    n_accept = 0
    K = length(ys)

    prog = Progress(N_samples; enabled=progress)
    for i in 1:N_samples
        G = calc_G(zs_curr, ssm)
        G_chol = cholesky(G)
        U = BlockVector{Float64,4}([@SVector randn(rng, 4) for k in 1:K])
        ps_curr = G_chol.U.data' * U
        H_curr = calc_hamiltonian(zs_curr, ps_curr, ys, ssm)
        zs_new = copy(zs_curr)
        ps_new = copy(ps_curr)

        for _ in 1:n_steps
            zs_new, ps_new = glf_step(zs_new, ps_new, ys, ssm, lf_params)
        end

        # Accept or reject
        H_new = calc_hamiltonian(zs_new, ps_new, ys, ssm)

        if log(rand(rng)) < H_curr - H_new
            zs_curr = zs_new
            n_accept += 1
        end

        zs_samples[i] = copy(zs_curr)
        next!(prog)
    end

    println("Finishing sampling with acceptance rate $(n_accept / N_samples)")

    return zs_samples
end

z_init = zs_true
zs_samples = Vector{BlockVector{Float64,4}}(undef, N_samples)

sample!(zs_samples, rng, ssm, z_init, ys, N_samples, N_burnin, n_steps, lf_params);

# Plot true and inferred trajectories
p1 = plot(; title="Position", xlabel="x", ylabel="y", legend=:topright)
for i in 1:N_samples
    zs_sample = zs_samples[i]
    plot!(
        p1,
        [z[1] for z in zs_sample.blocks],
        [z[2] for z in zs_sample.blocks];
        label="",
        lw=1,
        alpha=0.1,
        color=:blue,
    )
end
plot!(
    p1,
    [z[1] for z in zs_true.blocks],
    [z[2] for z in zs_true.blocks];
    label="True",
    lw=2,
    color=:black,
)
# Add sensor locations
scatter!(p1, [a1, a2], [b1, b2]; label="Sensors", color=:red, ms=8, marker=:star5)
display(p1)

@profview sample!(
    zs_samples,
    rng,
    ssm,
    z_init,
    ys,
    N_samples,
    N_burnin,
    n_steps,
    lf_params;
    progress=false,
)

# Plot 2D density of some middle time velocity
K_test = K ÷ 2
vx_samples = [zs_samples[i].blocks[K_test][3] for i in 1:N_samples]
vy_samples = [zs_samples[i].blocks[K_test][4] for i in 1:N_samples]
p2 = histogram2d(
    vx_samples,
    vy_samples;
    nbins=30,
    xlabel="v_x",
    ylabel="v_y",
    title="Velocity Density at t=$(K_test)",
);
display(p2)

# Plot trace for middle time positions and velocities (stacked)
ps = []
for d in 1:4
    push!(ps, plot(; xlabel="Sample", ylabel="Dimension $d", legend=false))
    plot!(
        ps[end], [zs_samples[i].blocks[K_test][d] for i in 1:N_samples]; lw=1, color=:blue
    )
    hline!(ps[end], [zs_true.blocks[K_test][d]]; lw=2, color=:black, label="True")
end
display(plot(ps...; layout=(4, 1), size=(600, 800)))

# Compute effective sample size
using MCMCDiagnosticTools

# Shape into (draws, [chains[, parameters...]])
rhmc_samples = Array{Float64}(undef, N_samples, 1, 4 * K)
for i in 1:N_samples
    for k in 1:K
        for d in 1:4
            rhmc_samples[i, 1, 4 * (k - 1) + d] = zs_samples[i].blocks[k][d]
        end
    end
end
rhmc_ess = ess(rhmc_samples)

println("Average relative ESS per dimension for RHMC: $(mean(rhmc_ess) / N_samples)")
